
#' This is modified based on TrackSig's oringinal compute_mutational_signatures.R
#' \code{setUpCompute} source the TrackSig/src/header.R code as required for TrackSig
#'
#' \code{setUpCompute} The framework of TrackSig requires to header.R to be sourced
#' to run the following functions.
#' @param path absolute path of header.R in your TrackSig/src folder
#' @examples
#' path <- "c://User//cindy//Documents//BCB410//TrackSig//src//header.R"
#' setUpCompute(path)
#' @export
setUpCompute <- function(path){
  source(path)
}

# ==============================================================================================

# source("src/header.R")
library(gridExtra)

group = 0
EXAMPLES_PER_GROUP <- 500

# ==============================================================================================

#' \code{save_data_for_samples} Prepare all the data needed for plots
#'
#' \code{save_data_for_samples} Please see 
#' \url{https://github.com/YuliaRubanova/TrackSig/blob/master/src/compute_mutational_signatures.R}
#' @param dir_counts default data/counts generated by make_counts.sh
#' @param bootstrap_counts default data/bootstrap generated by make_counts.sh
#' @examples
#' save_data_for_samples()
#' @export
save_data_for_samples <- function(dir_counts = DIR_COUNTS,  bootstrap_counts = BOOTSTRAP_COUNTS)
{
  if (!file.exists(SAVED_SAMPLES_DIR)) {
    dir.create(SAVED_SAMPLES_DIR, recursive = T)
  }
  
  tumors <- gsub("([^/]*)\\.phi\\.txt","\\1", list.files(dir_counts)) 
  
  examples_group <- get_examples_group(tumors, EXAMPLES_PER_GROUP, group)
  
  for (example in examples_group)
  {
    print(paste0("Example ", example, " (", which(examples_group == example), " out of ", length(examples_group), ")"))    
    
    list[tumor_id, vcfData, phis, assigns_phylo_nodes, acronym, dir_name] <- extract_data_for_example(example, dir_counts, tumortypes, dir_create = F)
    
    if (is.null(vcfData))
    {
      print(paste0("No data read for example ", example))
      next
    }
    if (nrow(vcfData) == 0)
    {
      print(paste0("Zero rows for example " , example))
      next
    }
    if (nrow(vcfData) < 6) # Plots with less than 6 lines of data are meaningless so ignored
    {
      print(paste0("Less than 6 rows per example ", example))
      next
    }
    
    if (sliding_window) { 
      # Sliding window approach
      data_method <- "sliding400"
      window_size=400
      shift = window_size/100
      gap = 1
      vcf <- get_sliding_window_data(vcfData, shift=shift, gap = gap)
      phis_sliding_window <- get_sliding_window_data(toVerticalMatrix(phis), shift=shift)
      phis_sliding_window <- phis_sliding_window / shift
      
      phis_for_plot = phis_sliding_window
    } else {
      shift <- gap <- NULL
      data_method <- "chunk100"
      vcf <- t(vcfData)
      phis_for_plot <- phis_sliding_window <- phis
    }
    
    if (sum(phis_sliding_window < 0.001) > 0.2 * length(phis_sliding_window))
    {
      phis_for_plot = NULL
    }
    
    if (!is.null(phis_for_plot))
    {
      colnames(vcf) <- round(phis_sliding_window, 3)
    } else {
      colnames(vcf) <- NULL
    }
    
    if (!is.null(assigns_phylo_nodes))
    {
      assigns_phylo_nodes <-  as.factor(assigns_phylo_nodes)
      assigns_phylo_nodes_levels <- levels(assigns_phylo_nodes)
      assigns_phylo_nodes <- toVerticalMatrix(as.numeric(assigns_phylo_nodes))
      
      if (sliding_window) {
        assigns_phylo_nodes_sw <- get_sliding_window_data(assigns_phylo_nodes, shift=shift)
        assigns_phylo_nodes_sw <- assigns_phylo_nodes_sw / shift
        assigns_phylo_nodes_sw <- round(assigns_phylo_nodes_sw)
      } else {
        assigns_phylo_nodes_sw <- assigns_phylo_nodes
      } 
      
      for (l in 1:length(assigns_phylo_nodes_levels))
      {
        assigns_phylo_nodes_sw[assigns_phylo_nodes_sw == l] <- assigns_phylo_nodes_levels[l]
      }
      
      stopifnot(length(phis_for_plot) == length(assigns_phylo_nodes_sw))
    } else {
      assigns_phylo_nodes_sw = assigns_phylo_nodes
    }
    
    list[bootstrap_vcfs, bootstrap_phis] <- lapply(extract_bootstrap_data_for_example(example, bootstrap_counts), t)
    
    if (compute_bootstrap) {
      for (j in 1:length(bootstrap_phis))
      {
        if (sliding_window) {
          bootstrap_vcfs[[j]] <- get_sliding_window_data(bootstrap_vcfs[[j]], shift=shift, gap = gap)
          bootstrap_phis[[j]] <- get_sliding_window_data(toVerticalMatrix(bootstrap_phis[[j]]), shift=shift)
          bootstrap_phis[[j]] <- bootstrap_phis[[j]] / shift
        }
      }
    }
    
    save(vcfData, vcf, phis, phis_sliding_window, assigns_phylo_nodes, assigns_phylo_nodes_sw, 
         acronym, window, shift, gap, tumor_id, phis_for_plot, bootstrap_vcfs, bootstrap_phis,
         file = paste0(SAVED_SAMPLES_DIR, "/", example, ".RData"))
  }
}

# ==============================================================================================

#' \code{compute_signatures_for_all_examples} Generate activitracjectories of mutational signatures with patients
#' with multiple samples
#' \code{compute_signatures_for_all_examples} Please see:
#' \url{https://github.com/YuliaRubanova/TrackSig/blob/master/src/compute_mutational_signatures.R}
#' @param dir_counts default data/counts generated by make_counts.sh
#' @examples
#' compute_signatures_for_all_examples()
#' @export
compute_signatures_for_all_examples <- function(dir_counts = DIR_COUNTS)
{
  # group <- 0
  add_early_late_transition = TRUE
  
  age_signatures <- c("S1", "S5", "L1", "1", "5a", "5b")
  
  tumors <- gsub("([^/]*)\\.phi\\.txt","\\1", list.files(dir_counts)) 
  
  examples_group <- get_examples_group(tumors, EXAMPLES_PER_GROUP, group)
  
  mutation_types <- read.delim(trinucleotide_file, header=F)
  mutation_types <- paste(mutation_types[,1], mutation_types[,2], mutation_types[,3], sep="_")
  
  
  plots <- list()
  plots_count <- 1
  for (example in examples_group)
  {
    
    set.seed(which(examples_group == example))
    print(paste0("Example ", example, " (", which(examples_group == example), " out of ", length(examples_group), ")"))
    
    data_file = paste0(SAVED_SAMPLES_DIR, "/", example, ".RData")
    if (file.exists(data_file))
    {
      load(data_file)
    } else {
      print(paste0("Data file ", data_file, " does not exist"))
      next
    }
    
    
    if (sig_amount == "onlyKnownSignatures") {
      # Fit only known signatures
      list[alex.t, matched_type, acronym] <- get_signatures_for_current_sample(tumor_id, active_signatures.our_samples, alex, noise_sig)
    } else {
      alex.t <- alex
    }
    
    if (is.null(acronym) || acronym == "") {
      print(paste("ERROR: Cancer type not found for ", example))
      next
    }
    
    if (is.null(alex.t))
    {
      print(paste0("No active signatures for sample", example, " ...."))
      next
    }
    
    if (is.vector(alex.t)) {
      next
    }
    
    if (sum(vcf[apply(alex.t,1,sum) == 0,] != 0) != 0) {
      print(paste0("Sample ", example, ": some trinucleotides have probability 0 under the model, but their count is non-zero. Sot the count vector is impossible under the model."))
      next
    }
    
    dir_name <- paste0(DIR_RESULTS, acronym, "/", tumor_id, "/")
    
    suppressWarnings(dir.create(dir_name, recursive = T))  
    
    if (!is.null(phis_for_plot))
    { 
      write(phis_for_plot, file=paste0(dir_name, "phis.txt"), ncolumns=length(phis_for_plot))
    }
    
    method_name <- "iterativeChangePoints"
    
    if (!file.exists(paste0(dir_name, "mixtures.csv")) || !file.exists(paste0(dir_name, "changepoints.txt")))
    {
      if (changepoint_method == "PELT") {
        list[changepoints, mixtures] <- find_changepoints_pelt(vcf, alex.t)
      } else {
        list[bics, optimal, changepoints, mixtures] <- find_changepoints_over_all_signatures_one_by_one(vcf, alex.t, n_signatures = ncol(alex.t))
      }
      
      write.csv(mixtures, file=paste0(dir_name, "mixtures.csv"))
      
      n_col <- ifelse(length(changepoints) > 0, length(changepoints), 1)
      write(changepoints, file=paste0(dir_name, "changepoints.txt"), ncolumns=n_col)
    } else {
      mixtures <- read_mixtures(paste0(dir_name, "mixtures.csv"))
      cp_file = paste0(dir_name, "changepoints.txt")
      if (file.info(cp_file)$size == 1) {
        changepoints <- c()
      } else {
        changepoints <- unlist(read.table(cp_file, header=F))
      }
    }
    
    if (!is.null(assigns_phylo_nodes_sw)) {
      write(assigns_phylo_nodes_sw,  file=paste0(dir_name, "assignments.txt"), ncolumns=length(assigns_phylo_nodes_sw))
    } else  {
      n_clusters = transition_points = assigns_phylo_nodes_sw = NULL
    }
    
    age_signatures <- intersect(rownames(mixtures), age_signatures)
    
    plot_name <- paste0(dir_name, "/", acronym, "_", tumor_id, "_", sig_amount, postfix, ".pdf")
    
    if (PLOT_FULL_NAME)
    {
      plot_name <- paste0(dir_name, "/", acronym, "_", data_method, "_multMix_fittedPerTimeSlice_", sig_amount, "_noPrior_", method_name, postfix, ".pdf")
    }
    
    mark_cp <- !is.null(changepoints)
    plot_list <-plot_signatures(mixtures*100, plot_name=plot_name, phis = phis_for_plot, mark_change_points=mark_cp, change_points=changepoints, 
                                #assigns_phylo_nodes = assigns_phylo_nodes_sw, 
                                transition_points = transition_points,
                                scale=1.2)
    plots[[plots_count]] <- plot_list[[1]]
    mixtures.rescaled = NULL
    
    print(paste("Computed example", example))
    plots_count <- plots_count + 1
  }
  
  ######################################code written by xindi################################################
  # added a list to store the plots for multiple samples
  # visulize the two plots in R viewer
  grid.arrange(plots[[1]], plots[[2]], nrow = 1)
 
  # save both of them in one pdf for easier intepretation
  g <- arrangeGrob(plots[[1]], plots[[2]], nrow = 1)
  suppressWarnings(ggsave(file="multisample.pdf", g, width = 12*1.5, height=5))
  
}


# [END]